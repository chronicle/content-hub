<!-- Custom Widget / Integration Version when it was updated 49.0 -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link
    href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700,700i"
    rel="stylesheet">
  <link
    href='https://fonts.googleapis.com/css?family=Source Sans Pro'
    rel='stylesheet'>
  <title>Execute UDM Query</title>
  <style>
    /* Root Variables */
    :root {
      --widget-bg: rgb(33, 44, 68);
      --widget-font-family: 'Source Sans Pro', sans-serif;
      --widget-text-color: rgb(255, 255, 255);
      --widget-scrollbar-size: 12px;
      --widget-row-highlight-bg: rgb(47 61 91);
      /*Logo styles*/
      --logo-size: 48px;
      --logo-color: rgb(255, 255, 255);
      /*Logo styles*/
      /*Table styles*/
      --table-color-even-row: rgb(26 32 50);
      --table-title-size: 600 14px/18px var(--widget-font-family);
      --table-th-size: 600 14px/18px var(--widget-font-family);
      --table-td-size: 400 14px/18px var(--widget-font-family);
    }

    /*Normalize CSS */
    * {
      margin: 0;
      padding: 0;
      outline: none;
      box-sizing: border-box;
    }

    *:hover, *:focus, *:active {
      outline: none;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      border-spacing: 0;
    }

    ol, ul {
      list-style: none;
    }

    button,
    input,
    textarea {
      font-family: inherit;
      background: transparent;
      border: 0;
      color: inherit;
      text-align: left;
    }

    button, a[href] {
      cursor: pointer;
    }

    /*Normalize CSS */
    /* Custom Scrollbar */
    ::-webkit-scrollbar {
      width: 18px;
      height: 18px;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(137, 151, 180, 1);
      border: 6px solid var(--widget-bg);
      border-radius: 63px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
      border: 4px solid transparent;
      border-radius: 44px;
    }

    ::-webkit-scrollbar-corner {
      background-color: transparent;
      border-color: transparent;
    }

    body {
      font-family: var(--widget-font-family), serif;
      color: var(--widget-text-color);
      background-color: var(--widget-bg);
      overflow: hidden;
    }

    /*Global styles*/
    .text-ellipsis {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .tooltip {
      max-width: 100%;
      position: absolute;
      padding: 8px 16px 8px 16px;
      border-radius: 4px;
      background-color: rgb(204 204 218);
      color: rgb(22, 22, 37);
      font: 400 14px/18px var(--widget-font-family);
      z-index: 99;
      word-wrap: break-word;
    }

    .tooltip-triangle {
      position: absolute;
      top: 100%;
      border-top: solid 8px rgb(195, 210, 232);
      border-left: solid 8px transparent;
      border-right: solid 8px transparent;
    }

    .input {
      border: 1px solid #6275A3;
      border-radius: 4px;
      padding: 4px 8px;
      background-color: transparent;
      font-size: 14px;
      color: var(--widget-text-color);
    }

    .input::placeholder {
      color: var(--widget-text-color);
    }

    input[type="checkbox"] {
      max-width: 13px;
      max-height: 13px;
    }

    /*Global styles*/
    /*Table*/
    .table-wrapper {
      margin-top: 8px;
      position: relative;
    }

    .table-search {
      display: flex;
      justify-content: flex-end;
    }

    .table-container {
      overflow: auto;
      max-height: calc(100vh - 102px);
    }

    .table {
      table-layout: fixed;
    }

    .table thead {
      position: sticky;
      top: 0;
      z-index: 9;
    }

    .table th {
      width: 250px;
      background-color: var(--widget-row-highlight-bg);
      color: var(--widget-text-color);
      font: var(--table-th-size);
      padding: 6px 12px;
      text-transform: uppercase;
      vertical-align: top;
      text-align: left;
    }

    .table tr:nth-child(even) {
      background-color: var(--table-color-even-row);
    }

    .table-resizable-line {
      position: absolute;
      inset: 3px 6px 3px auto;
      width: 2px;
      cursor: col-resize;
      user-select: none;
      background-color: rgb(98, 117, 163);
      z-index: 9;
    }

    .table-resizable-line::before, .table-resizable-line::after {
      content: '';
      position: absolute;
      inset: 0 auto;
      width: 6px;
    }

    .table-resizable-line::before {
      left: -6px;
    }

    .table-resizable-line::after {
      right: -6px;
    }

    .table td {
      padding: 8px 12px;
      font: var(--table-td-size);
      color: var(--widget-text-color);
      vertical-align: top;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .logo {
      min-width: var(--logo-size);
      min-height: var(--logo-size);
      max-width: var(--logo-size);
      max-height: var(--logo-size);
      color: var(--logo-color);
    }

    .counter {
      display: flex;
      align-items: center;
      gap: 6px;
      margin: 0 auto;
    }

    .counter-number {
      font: 600 20px/24px var(--widget-font-family);
      text-align: center;
    }

    .counter-title {
      font: 600 16px/22px var(--widget-font-family);
      text-transform: uppercase;
      text-align: center;
    }

    .table-events {
      display: flex;
      align-items: center;
      gap: 12px;
      justify-content: flex-end;
      margin-bottom: 12px;
      padding: 0 6px;
    }

    .table-udm-label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding-left: 4px;
      cursor: pointer;
    }

    .table-udm-label-text {
      font-size: 14px;
    }

    /* Dropdown */
    .dropdown-button {
      width: 24px;
      height: 24px;
      cursor: pointer;
    }

    .dropdown-container {
      width: 24px;
      height: 24px;
      margin-right: auto;
      position: relative;
    }

    .dropdown {
      position: absolute;
      top: 100%;
      background-color: var(--widget-bg);
      min-width: 270px;
      max-width: 280px;
      padding: 12px 16px;
      z-index: 99;
      box-shadow: 0 4px 6px 3px rgba(0, 0, 0, 0.6);
      border-radius: 4px;
      flex-direction: column;
      display: none;
    }

    @media (max-height: 400px) {
      .dropdown {
        max-height: 280px;
      }
    }

    .dropdown.show {
      display: flex;
    }

    .dropdown-list {
      margin-top: 12px;
      margin-right: -15px;
      max-height: 300px;
      overflow: auto;
    }

    .dropdown-events {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .dropdown-search {
      width: 100%;
    }

    .dropdown-list-select {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
    }

    .dropdown-list-select-text {
      font-size: 14px;
      white-space: nowrap;
    }

    .dropdown-list-label {
      display: flex;
      align-items: center;
      gap: 6px;
      width: 100%;
      cursor: pointer;
      padding: 12px 0;
    }
  </style>
</head>
<body>
<div class="header">
  <div class="counter">
    <h1 class="counter-number" id="counterNumber"></h1>
    <h2 class="counter-title" id="counterTitle"></h2>
  </div>
  <svg class="logo" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 21 23" width="100%" height="100%" fill="currentColor"> <defs> <style> .cls-1 { stroke-width: 0px; } </style> </defs> <path class="cls-1" d="M15.51,4.79H5.49c-.4,0-.72.32-.72.72v5.75c0,2.3,1.71,4.15,3.69,5.38.54.34,1.1.62,1.66.86l.09.04c.06.02.12.05.18.06.03,0,.07,0,.1,0,.1,0,.19-.03.28-.07l.09-.04c.76-.33,2.22-1.03,3.46-2.24,1.24-1.22,1.89-2.6,1.89-4v-5.75c0-.4-.32-.72-.72-.72ZM14.32,11.26c0,.88-.44,1.77-1.32,2.63-.65.64-1.55,1.22-2.5,1.68-.95-.46-1.84-1.04-2.5-1.68-.88-.86-1.32-1.75-1.32-2.63v-4.55h7.64v4.55ZM20.28,0H.72c-.4,0-.72.32-.72.72v10.77c0,2.56,1.18,4.99,3.51,7.21,2.29,2.18,5.12,3.56,6.61,4.2l.09.04s.1.04.15.05c.04,0,.09.01.13.01.1,0,.19-.02.28-.06l.09-.04c.53-.23,1.23-.55,2.02-.97,1.42-.75,3.11-1.82,4.59-3.23,2.33-2.22,3.51-4.64,3.51-7.21V.72c0-.4-.32-.72-.72-.72ZM16.17,17.31c-1.9,1.81-4.24,3.04-5.67,3.69-1.43-.65-3.77-1.88-5.67-3.69-1.94-1.84-2.92-3.8-2.92-5.82V1.92h17.18v9.57c0,2.02-.98,3.98-2.92,5.82Z"></path></svg>
</div>
<div class="table-wrapper" id="tableWrapper">
  <div class="table-events">
    <div class="dropdown-container">
      <svg class="dropdown-button" id="columnsIcon" width="24" height="24"
           viewBox="0 0 24 24"
           xmlns="http://www.w3.org/2000/svg"
           fill="currentColor">
        <path
          d="M4 6v12.444h16V6H4zm4.738 10.667h-2.96v-8.89h2.96v8.89zm4.746 0h-2.96v-8.89h2.96v8.89zm4.738 0h-2.96v-8.89h2.96v8.89z"></path>
      </svg>
      <div id="dropdown" class="dropdown">
        <div class="dropdown-events">
          <input class="input dropdown-search" type="text" id="dropdownSearch"
                 placeholder="Search (regex)">
          <label class="dropdown-list-select" for="selectAll">
            <span class="dropdown-list-select-text" id="selectAllText"></span>
            <input type="checkbox" id="selectAll" checked>
          </label>
        </div>
        <div class="dropdown-list" id="dropdownList"></div>
      </div>
    </div>
    <label class="table-udm-label" for="predefinedFieldsCheckbox"
           id="predefinedFieldsCheckboxLabel">
      <input type="checkbox" id="predefinedFieldsCheckbox">
      <span class="table-udm-label-text">Important UDM</span>
    </label>
    <input class="input table-search" type="text" autocomplete="off" id="searchInput"
           placeholder="Search (regex)"/>
  </div>
  <div class="table-container">
    <table class="table">
      <thead id="tableHeader"></thead>
      <tbody id="tableBody"></tbody>
    </table>
  </div>
</div>
<script>

  const actionListData = [[{stepInstanceName}.JsonResult | "events"]];

  // Create a new array, 'specifiedKeys', by mapping over an existing array.
  const specifiedKeys = ["entity.asset.asset_id", "entity.asset.hostname", "entity.asset.ip", "entity.asset.mac", "entity.asset.product_object_id", "entity.file", "entity.group.email_address", "entity.group.product_object_id", "entity.group.windows_sid", "entity.hostname", "entity.resource.name", "entity.resource.product_object_id", "entity.url", "entity.user.email_address", "entity.user.employee_id", "entity.user.product_object_id", "entity.user.userid", "entity.user.windows_sid", "metadata.collected_timestamp", "metadata.threat", "metadata.description", "metadata.event_timestamp", "metadata.event_type", "metadata.ingestion_labels.key", "metadata.ingestion_labels.value", "metadata.product_deployment_id", "metadata.product_event_type", "metadata.product_log_id", "metadata.product_name", "metadata.vendor_name", "network.application_protocol", "network.dns_domain", "network.dns.answers.data", "network.dns.answers.name", "network.dns.answers.type", "network.dns.questions.name", "network.dns.questions.type", "network.email.bcc", "network.email.email.cc", "network.email.from", "network.email.reply_to", "network.email.subject", "network.email.to", "network.ftp.command", "network.http.method", "network.http.referral_url", "network.http.response_code", "network.http.user_agent", "network.ip_protocol", "principal.asset_id", "principal.asset.asset_id", "principal.asset.hostname", "principal.asset.ip", "principal.asset.mac", "principal.cloud.environment", "principal.file.full_path", "principal.file.md5", "principal.file.sha1", "principal.file.sha256", "principal.hostname", "principal.ip", "principal.mac", "principal.process.command_line", "principal.process.file.full_path", "principal.process.parent_process", "principal.process.parent_process.command_line", "principal.process.parent_process.file.full_path", "principal.process.pid", "principal.process.product_specific_process_id", "principal.registry.registry_key", "principal.registry.registry_value_name", "principal.resource.attribute.cloud.project.name", "principal.resource.attribute.cloud.project.resource_subtype", "principal.resource.name", "principal.url", "principal.user.attribute.permissions.name", "principal.user.attribute.permissions.type", "principal.user.attribute.roles.description", "principal.user.attribute.roles.name", "principal.user.email_address", "principal.user.product_object_id", "principal.user.userid", "principal.user.windows_sid", "security_result.action", "security_result.category", "security_result.description", "security_result.detection_fields.key", "security_result.detection_fields.value", "security_result.summary", "security_result.threat_id", "security_result.threat_id_namespace", "security_result.threat_name", "source.asset_id", "source.asset.asset_id", "source.asset.hostname", "source.asset.ip", "source.asset.mac", "source.file.md5", "source.file.sha1", "source.file.sha256", "source.hostname", "source.ip", "source.mac", "source.process.parent_process", "source.process.product_specific_process_id", "source.user.email_address", "source.user.product_object_id", "source.user.userid", "source.user.windows_sid", "target.application", "target.asset_id", "target.asset.asset_id", "target.asset.hostname", "target.asset.ip", "target.asset.mac", "target.cloud.environment", "target.cloud.project.name", "target.file.full_path", "target.file.md5", "target.file.sha1", "target.file.sha256", "target.hostname", "target.ip", "target.mac", "target.port", "target.process.command_line", "target.process.file.full_path", "target.process.parent_process", "target.process.parent_process.command_line", "target.process.parent_process.file.full_path", "target.process.pid", "target.process.product_specific_process_id", "target.registry.registry_key", "target.registry.registry_value_name", "target.resource.name", "target.resource.resource_type", "target.user.email_address", "target.user.product_object_id", "target.user.userid", "target.user.windows_sid"].map(key => key.replace(/[\W_]/g, "").toLowerCase());

  // Set to "true" to have with specifiedKeys on initial load
  predefinedFieldsCheckbox.checked = false;

  // Constants and let for tooltip positioning
  const tooltipGap = 25;
  const tooltipTriangleHeight = 8;
  const tooltipTriangleMinGap = 5;
  const triangleWidth = 16;
  let tooltipTimeout = undefined;

  // Extract keys and values from actionListData
  const allKeys = getAllKeys(actionListData);
  const allValues = getAllValues(actionListData);

  // Modify keys for uniformity and prepare for filtering
  const modifiedAllKeys = allKeys.map(key => key.replace(/^udm\./, "").replace(/[\W_]/g, "").toLowerCase());

  // Initialize arrays and objects for processing
  const specifiedKeysInAll = [];
  const allKeysRecords = {};

  // Populate specifiedKeysInAll and allKeysRecords
  modifiedAllKeys.forEach((key, index) => {
    const keyInAll = allKeys[index];
    allKeysRecords[keyInAll] = index;
    if (specifiedKeys.includes(key)) {
      specifiedKeysInAll.push(keyInAll);
    }
  });

  // Event listeners for UI interactions
  columnsIcon.addEventListener("click", function (event) {
    dropdown.classList.toggle("show");
    event.stopPropagation();
  });
  document.addEventListener("click", function (event) {
    if (!dropdown.contains(event.target) && event.target !== columnsIcon) {
      dropdown.classList.remove("show");
    }
  });
  dropdownSearch.addEventListener("input", debounce(filterDropdown, 300));
  searchInput.addEventListener("input", debounce(generateTable, 500));
  selectAll.addEventListener("change", function () {
    getDropdownListCheckboxes().forEach(function (checkbox) {
      checkbox.checked = selectAll.checked;
    });
    generateTable();
  });
  predefinedFieldsCheckbox.addEventListener("change", () => {
    generateDropdown();
    generateTable();
  });
  const tooltipDetectResizeObserver = new ResizeObserver((entries) => {
    for (const entry of entries) {
      const target = entry.target;
      if (target) {
        const {offsetWidth, scrollWidth} = target;
        if (scrollWidth > offsetWidth) {
          target.addEventListener("mouseover", createTooltipListener);
          target.addEventListener("mouseout", removeTooltipListener);
        } else {
          target.removeEventListener("mouseover", createTooltipListener);
          target.removeEventListener("mouseout", removeTooltipListener);
        }
      }
    }
  });

  // Generate dropdown on page load
  generateDropdown();

  if (specifiedKeys.length === 0) {
    predefinedFieldsCheckboxLabel.remove();
  }

  /**
   * Function to get selected column indexes
   */
  function getSelectedColumnsIndexes() {
    const selectedCheckBoxes = getDropdownListCheckboxes().filter(checkbox => !!checkbox.checked);
    return selectedCheckBoxes.map(checkbox => allKeysRecords[checkbox.value]);
  }

  function escapeRegExp(string) {
    return string.replace(/([+])/g, "\\$1");
  }

  /**
   * Generates the table based on current selections and filters.
   */
  function generateTable() {
    const searchQuery = getSearchValue();
    const selectedColumnIndexes = getSelectedColumnsIndexes();
    const isSelectAll = selectedColumnIndexes.length === allKeys.length;
    const rowValues = isSelectAll ? allValues : allValues.map(rowData => rowData.filter((data, index) => selectedColumnIndexes.includes(index)));
    const escapedQuery = escapeRegExp(searchQuery);
    const regexPattern = new RegExp(escapedQuery, "gi");

    generateTableHeader(isSelectAll ? undefined : selectedColumnIndexes);

    if (!searchQuery) {
      generateTableBody(rowValues);
    } else {
      const filteredRows = rowValues.filter(item =>
        item.some(value =>
          (typeof value === "string" && regexPattern.test(value)) ||
          (typeof value === "number" && regexPattern.test(value.toString())),
        ),
      );
      generateTableBody(filteredRows, searchQuery);
    }
  }

  /**
   * Generates the table header based on selected columns.
   */
  function generateTableHeader(indexesToRender) {
    let keysToRender = allKeys;
    tableHeader.innerHTML = "";
    if (Array.isArray(indexesToRender)) {
      if (indexesToRender.length === 0) {
        return;
      }
      keysToRender = allKeys.filter((key, index) => indexesToRender.includes(index));
    }
    const table_tr = document.createElement("tr");
    keysToRender.forEach((key) => {
      const table_th = document.createElement("th");
      const table_th_div = document.createElement("div");
      renderWithTooltip(table_th_div, key.replace(/\./g, "."));
      table_th.appendChild(table_th_div);
      table_tr.appendChild(table_th);
      tableHeader.appendChild(table_tr);
    });

    resizableGrid();

  }

  /**
   * Generates the table body based on rows to render and search query.
   */
  function generateTableBody(rowsToRender, searchQuery = "") {
    tableBody.innerHTML = "";

    const escapedQuery = escapeRegExp(searchQuery);
    const regexPattern = new RegExp(escapedQuery, "gi");

    rowsToRender.forEach(item => {
      const row = document.createElement("tr");
      item.forEach(value => {
        const cell = document.createElement("td");
        renderWithTooltip(cell, value);
        if (typeof value === "string" && searchQuery && regexPattern.test(value)) {
          cell.innerHTML = value.replace(regexPattern, match => `<mark style="pointer-events: none">${match}</mark>`);
        } else if (typeof value === "number" && searchQuery && regexPattern.test(value.toString())) {
          cell.innerHTML = value.toString().replace(regexPattern, match => `<mark style="pointer-events: none">${match}</mark>`);
        } else if (value === undefined || value === null || value === "") {
          cell.textContent = "N/A";
        } else {
          cell.textContent = value;
        }
        row.appendChild(cell);
      });
      tableBody.appendChild(row);
    });

    updateCounter();
  }

  /**
   * Updates the counter displaying the number of rows in the table.
   */
  function updateCounter() {
    const rowCount = tableBody.rows.length;
    counterTitle.innerText = rowCount === 1 ? "Event found" : "Events found";
    counterNumber.innerText = rowCount;
  }

  /**
   * Retrieves all unique keys from nested data structures.
   */
  function getAllKeys(data) {
    const allKeys = new Set();
    const prePathMaxIndexesMap = new Map();

    function traverse(obj, path = "") {
      for (const key in obj) {
        if (Array.isArray(obj[key])) {
          obj[key].forEach((item, index) => {
            if (typeof item === "object" && item !== null) traverse(item, `${path}${key}.${index}.`);
            else {
              const prePath = `${path}${key}`;
              if (!allKeys.has(prePath)) allKeys.add(prePath);
              else {
                const currentMaxIndex = prePathMaxIndexesMap.get(prePath) ?? -1;
                if (index > currentMaxIndex) prePathMaxIndexesMap.set(prePath, index);
              }
            }
          });
        } else if (typeof obj[key] === "object" && obj[key] !== null) traverse(obj[key], `${path}${key}.`);
        else allKeys.add(`${path}${key}`);
      }
    }

    data.forEach((item) => traverse(item));
    return Array.from(allKeys).flatMap(key => {
      if (prePathMaxIndexesMap.has(key)) {
        const maxIndex = prePathMaxIndexesMap.get(key);
        return Array.from(Array(maxIndex + 1).keys()).map(index => `${key}.${index}`);
      }
      return key;
    });
  }

  /**
   * Retrieves all values corresponding to keys from nested data.
   */
  function getAllValues(data) {
    const allValues = data.map(item => flattenObject(item));
    return allValues.map((obj) => allKeys.map(key => obj[key] !== undefined ? obj[key] : ""));
  }

  /**
   * Flattens nested objects into key-value pairs.
   */
  function flattenObject(obj, prefix = "") {
    return Object.keys(obj).reduce((acc, key) => {
      const pre = prefix.length ? `${prefix}.` : "";
      if (typeof obj[key] === "object" && obj[key] !== null && !Array.isArray(obj[key])) {
        Object.assign(acc, flattenObject(obj[key], `${pre}${key}`));
      } else if (Array.isArray(obj[key])) {
        obj[key].forEach((item, index) => {
          if (typeof item === "object" && item !== null) Object.assign(acc, flattenObject(item, `${pre}${key}.${index}`));
          else acc[`${pre}${key}.${index}`] = item;
        });
      } else acc[`${pre}${key}`] = obj[key];
      return acc;
    }, {});
  }

  /**
   * Retrieves the current search value from the input field.
   */
  function getSearchValue() {
    return searchInput.value.trim().toLowerCase() ?? "";
  }

  /**
   * Retrieves the state of the UDM list checkbox.
   */
  function getUDMListChecked() {
    return !!predefinedFieldsCheckbox.checked;
  }

  /**
   * Retrieves checkboxes within the dropdown list.
   */
  function getDropdownListCheckboxes() {
    return Array.from(dropdownList.querySelectorAll("[data=\"dropdown-list-checkbox\"]"));
  }

  /**
   * Debounce function execution to optimize performance.
   */
  function debounce(func, delay) {
    let timeoutId;
    return function (...args) {
      if (timeoutId) clearTimeout(timeoutId);
      timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
  }

  /**
   * Generates the dropdown menu based on selected options.
   */
  function generateDropdown() {
    dropdownList.innerHTML = "";
    selectAllText.innerText = "Select all";
    const isUdmListChecked = getUDMListChecked();
    const keysToGenerate = isUdmListChecked ? specifiedKeysInAll : allKeys;
    keysToGenerate.forEach(key => {
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.value = key;
      checkbox.setAttribute("data", "dropdown-list-checkbox");
      checkbox.checked = true;
      checkbox.addEventListener("change", () => {
        generateTable();
        updateSelectAllCheckbox();
      });
      const label = document.createElement("label");
      label.className = "dropdown-list-label";
      label.setAttribute("data", "dropdown-list-label");
      const labelKey = document.createElement("span");
      label.appendChild(checkbox);
      labelKey.appendChild(document.createTextNode(key));
      renderWithTooltip(labelKey, key);
      label.appendChild(labelKey);
      dropdownList.appendChild(label);
    });
  }

  /**
   * Update the selectAll checkbox state based on individual checkboxes
   */
  function updateSelectAllCheckbox() {
    const checkboxes = getDropdownListCheckboxes();
    const allChecked = checkboxes.every(checkbox => checkbox.checked);
    selectAll.checked = allChecked;
  }

  /**
   * Filters dropdown options based on user input.
   */
  function filterDropdown() {
    const searchTerm = dropdownSearch.value.trim();
    const regex = new RegExp(searchTerm, "gi");
    dropdownList.querySelectorAll("[data=\"dropdown-list-label\"]").forEach(label => {
      const checkbox = label.children[0];
      label.style.display = checkbox?.value.match(regex) ? "flex" : "none";
    });
  }

  /**
   * Creates a tooltip with given text and position.
   */
  function createTooltip(text, x, y, trianglePointX, placeAtBottom, contentOverflowWindow) {
    removeTooltip();
    const tooltip = document.createElement("div");
    tooltip.classList.add("tooltip");
    tooltip.textContent = text;
    tooltip.style.left = `${x}px`;
    tooltip.style.top = `${y}px`;
    if (contentOverflowWindow) {
      tooltip.style.right = `${tooltipGap}px`;
    }
    const tooltipTriangle = document.createElement("span");
    tooltipTriangle.classList.add("tooltip-triangle");
    tooltipTriangle.style.left = `${trianglePointX}px`;
    if (placeAtBottom) {
      tooltipTriangle.style.top = "-8px";
      tooltipTriangle.style.borderTop = "0";
      tooltipTriangle.style.borderBottom = "solid 8px rgb(195, 210, 232)";
    }
    tooltip.append(tooltipTriangle);
    document.body.append(tooltip);
  }

  /**
   * Removes any existing tooltip from the DOM.
   */
  function removeTooltip() {
    const tooltip = document.querySelectorAll(".tooltip");
    tooltip.forEach((item) => {
      if (item) {
        item.remove();
      }
    });
  }

  /**
   * Sets a timeout to calculate and show tooltip position after a delay.
   */
  function createTooltipListener(event) {
    tooltipTimeout = setTimeout(() => calculateTooltipPosition(event), 1000);
  }

  /**
   * Clears any existing tooltip timeout and removes the tooltip.
   */
  function removeTooltipListener() {
    if (tooltipTimeout) {
      clearTimeout(tooltipTimeout);
    }
    removeTooltip();
  }

  /**
   * Calculates and positions the tooltip relative to the event target.
   */
  function calculateTooltipPosition(event) {
    const target = event.target;
    if (!target) {
      return;
    }
    const viewportWidth = window.innerWidth;
    const rect = target.getBoundingClientRect();
    const tooltipContent = document.createElement("div");
    tooltipContent.classList.add("tooltip");
    tooltipContent.style.top = "0";
    tooltipContent.textContent = target.textContent;
    document.body.appendChild(tooltipContent);
    let contentOverflowWindow = false;
    // Determine if window width would not be enough for content of tooltip
    if (tooltipGap * 2 + tooltipContent.offsetWidth >= viewportWidth) {
      // setting left, right positions to get correct tooltipContentWidth and tooltipContentHeight
      tooltipContent.style.left = `${tooltipGap}px`;
      tooltipContent.style.right = `${tooltipGap}px`;
      contentOverflowWindow = true;
    }
    const tooltipContentWidth = tooltipContent.offsetWidth;
    const tooltipContentHeight = tooltipContent.offsetHeight;
    tooltipContent.remove();
    const elementMidX = rect.left + (rect.width / 2);
    const placeOnRight = elementMidX + tooltipContentWidth / 2 + tooltipGap > viewportWidth;
    const x = Math.max(tooltipGap, placeOnRight ? viewportWidth - tooltipContentWidth - tooltipGap : elementMidX - tooltipContentWidth / 2);
    const placeAtBottom = rect.top < tooltipContentHeight;
    const y = placeAtBottom ? rect.bottom + tooltipTriangleHeight : rect.top - tooltipContentHeight;
    // Calculating trianglePointX relative to window width, to guarantee that it is not out of window
    const trianglePointX = Math.min(Math.max(elementMidX - x, tooltipTriangleMinGap), tooltipContentWidth - tooltipTriangleMinGap - triangleWidth);
    createTooltip(target.textContent, x, y, trianglePointX, placeAtBottom, contentOverflowWindow);
  }

  /**
   * Renders an item with text and sets up tooltip behavior.
   */
  function renderWithTooltip(item, text) {
    item.innerText = text;
    item.classList.add("text-ellipsis");
    tooltipDetectResizeObserver.observe(item);
  }

  /**
   * Function to make a table resizable
   */
  function resizableGrid() {
    const table = document.querySelector(".table");
    if (!table) return;

    const row = table.getElementsByTagName("tr")[0],
      cols = row ? row.children : undefined;
    if (!cols) return;

    for (let i = 0; i < cols.length; i++) {
      const div = createDiv();
      cols[i].appendChild(div);
      cols[i].style.position = "relative";
      setListeners(div);
    }

    function setListeners(div) {
      let pageX, curCol, nxtCol, curColWidth, nxtColWidth, tableWidth;

      div.addEventListener("mousedown", function (e) {
        curCol = e.target.parentElement;
        nxtCol = curCol.nextElementSibling;
        pageX = e.pageX;

        const padding = paddingDiff(curCol);

        curColWidth = curCol.offsetWidth - padding;
        if (nxtCol) {
          nxtColWidth = nxtCol.offsetWidth - padding;
        }
      });

      document.addEventListener("mousemove", function (e) {
        if (curCol) {
          const diffX = e.pageX - pageX;
          if (nxtCol) {
            nxtCol.style.width = nxtColWidth - diffX + "px";
          }
          curCol.style.width = curColWidth + diffX + "px";
          table.style.width = tableWidth + diffX + "px";
        }
      });

      document.addEventListener("mouseup", function () {
        curCol = undefined;
        nxtCol = undefined;
        pageX = undefined;
        nxtColWidth = undefined;
        curColWidth = undefined;
        tableWidth = undefined;
      });
    }

    function createDiv() {
      const div = document.createElement("div");
      div.classList.add("table-resizable-line");
      return div;
    }

    function paddingDiff(col) {
      if (getStyleVal(col, "box-sizing") === "border-box") {
        return 0;
      }

      const padLeft = getStyleVal(col, "padding-left");
      const padRight = getStyleVal(col, "padding-right");
      return parseInt(padLeft) + parseInt(padRight);
    }

    function getStyleVal(elm, css) {
      return window.getComputedStyle(elm, null).getPropertyValue(css);
    }
  }

  window.addEventListener("load", () => {
    // Generate table on page load
    generateTable();
  });
</script>
</body>
</html>
